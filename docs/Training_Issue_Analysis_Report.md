# ⚠️ [아카이브] 학습 성능 저하 원인 분석 및 개선 방안

> **⚠️ 중요: 이 문서는 더 이상 사용되지 않습니다**
>
> **아카이브 사유**: 2025-10-31부로 프로젝트가 **이중 YOLO 모델 아키텍처**로 전환되었습니다.
>
> **이 문서의 내용**:
> - 구 데이터셋 (DeepPCB + Kaggle 병합, 29→22 클래스)의 학습 문제 분석
> - 극심한 클래스 불균형 (264.6 : 1)
> - 극소 샘플 클래스 (7개, 116-420개)
> - 낮은 성능 (mAP50 56.22%)
>
> **문제 해결**:
> - 이 분석 결과를 바탕으로 **이중 모델 아키텍처**로 전환하였습니다.
> - **Component Model**: FPIC-Component 데이터셋 (25 클래스, 6,260 이미지, 균형 잡힌 분포)
> - **Solder Model**: SolDef_AI 데이터셋 (5-6 클래스, 429/1,150 이미지)
> - 각 모델이 전문 영역에 집중하여 **높은 정확도** 달성
>
> **새 문서 참조**: `docs/YOLO_Training_Guide.md` (v3.0, 이중 모델 학습 가이드)

---

**작성일**: 2025-10-31
**아카이브일**: 2025-10-31
**분석 대상**: 구 병합 데이터셋 (DeepPCB + Kaggle, 29→22 클래스)
**현재 성능**: mAP50 56.22% (목표: 95%)
**학습 에포크**: 114/300 (조기 중단)

---

## 📊 1. 현황 요약

### 전체 성능
- **mAP50**: 56.22%
- **mAP50-95**: 37.75%
- **Precision**: 59.58%
- **Recall**: 56.50%

### 클래스별 성능 분포
- **우수 (90%+)**: 6개 클래스 (PCB 불량 전체)
- **양호 (60-89%)**: 11개 클래스
- **불량 (40-59%)**: 5개 클래스
- **심각 (40% 미만)**: 7개 클래스

---

## 🔍 2. 핵심 문제점

### 2.1 극소 샘플 클래스 (7개)

| 클래스 | Train | Val | Test | mAP50 | 문제 |
|--------|-------|-----|------|-------|------|
| comp_fuse | 116 | 22 | 28 | **0.4%** | 학습 불가 |
| comp_buzzer | 124 | 22 | 26 | **10.6%** | 학습 불가 |
| comp_battery | 134 | 22 | 28 | **28.6%** | 심각 부족 |
| comp_display | 167 | 28 | 29 | **19.2%** | 심각 부족 |
| comp_clock | 152 | 55 | 39 | **20.3%** | 부족 |
| comp_pins | 286 | 42 | 14 | **2.2%** | Val 부족 |
| comp_switch | 420 | 81 | 62 | **4.5%** | 불균형 |

**문제**: Validation set에서 22-42개 샘플로는 신뢰성 있는 평가 불가능

### 2.2 클래스 불균형 (264.6 : 1)

| 구분 | 클래스 | 샘플 수 |
|------|--------|---------|
| **최대** | comp_resistor | 30,316개 |
| **최대** | comp_capacitor | 30,690개 |
| **최소** | comp_fuse | 116개 |
| **비율** | - | **264.6 : 1** |

**문제**: 모델이 다수 클래스(resistor, capacitor)에만 편향 학습

### 2.3 성능 극명한 차이

| 카테고리 | 평균 mAP50 | 최고 | 최저 |
|----------|-----------|------|------|
| **PCB 불량** (6개) | **97.5%** | 99.0% | 96.2% |
| **납땜 불량** (4개) | **58.2%** | 68.0% | 38.6% |
| **부품** (19개) | **43.8%** | 86.6% | 0.4% |

**의심**: 부품 데이터셋 라벨링 품질 문제

---

## 💡 3. 개선 방안

### 방안 1: 극소 클래스 제거 또는 병합 ⭐ **권장**

#### 1-A. 극소 클래스 7개 제거 (29 → 22 클래스)
```
제거 대상: fuse, buzzer, battery, display, clock, pins, switch
```

**장점**:
- 즉각적인 성능 향상 예상 (56% → 65%+)
- 학습 안정성 증가

**단점**:
- 실제 프로젝트에서 해당 부품 검출 불가

#### 1-B. 유사 클래스 병합 (29 → 24 클래스)
```
battery + relay → "small_component"
buzzer + fuse → "small_component"
pins + pads → "connection_component"
switch + button → "control_component"
```

**장점**:
- 샘플 수 증가
- 기능적 검출은 유지

**단점**:
- 세밀한 분류 불가

---

### 방안 2: 데이터 증강 강화 ⚠️ **보조 수단**

#### 2-A. 극소 클래스 타겟 증강
```python
# 증강 목표: 각 클래스 최소 500개
augmentation_plan = {
    'comp_fuse': 116 → 500 (4.3배)
    'comp_buzzer': 124 → 500 (4.0배)
    'comp_battery': 134 → 500 (3.7배)
    'comp_display': 167 → 500 (3.0배)
}

# 증강 기법
- Rotation: 15°, 30°, 45°, 90°
- Flip: H, V
- Brightness: ±20%
- Noise: Gaussian 3%
- Blur: Gaussian kernel 3
- Scale: 0.8-1.2x
- Copy-Paste: 부품을 다른 PCB로 복사
```

**효과**: 제한적 (근본 해결 아님)

#### 2-B. Class Weights 적용
```yaml
# 학습 시 클래스 가중치
class_weights = {
    comp_fuse: 264.6
    comp_buzzer: 247.3
    comp_battery: 229.0
    # ... 불균형 비율로 가중치 설정
}
```

---

### 방안 3: 하이퍼파라미터 최적화

#### 3-A. Image Size 증가 (640 → 1280)
```bash
imgsz=1280  # 작은 부품 검출 개선
```

**장점**: 작은 부품(fuse, buzzer) 검출 향상
**단점**: VRAM 사용량 4배 증가, 학습 속도 느림

#### 3-B. Batch Size 조정
```bash
batch=8   # VRAM 고려
nbs=64    # Gradient accumulation 유지
```

#### 3-C. Learning Rate 감소
```bash
lr0=0.0005  # 기존 0.001에서 50% 감소
```

---

### 방안 4: 모델 변경

#### 4-A. YOLOv8x (Extra Large) 사용
```bash
model=yolov8x.pt  # 기존 yolo11l.pt
```

**장점**: 56.9M 파라미터 (Large 대비 1.56배)
**단점**: 학습/추론 시간 증가

#### 4-B. YOLOv11 최신 모델
```bash
model=yolo11l.pt  # 2024년 최신 버전
```

---

### 방안 5: 데이터셋 품질 검증 ⭐ **최우선**

#### 5-A. Validation Set 수동 검증
```bash
# Val set 샘플 시각화 및 검증
python scripts/visualize_val_samples.py
```

**확인 사항**:
1. 라벨 정확도 (bbox 위치, 클래스)
2. 애매한 샘플 (흐린 이미지, 가려진 부품)
3. 중복 샘플
4. 잘못된 클래스 라벨

#### 5-B. 부품 데이터셋 재라벨링 고려
- PCB 불량: 96-99% (완벽)
- 부품 검출: 평균 43.8%
- **같은 데이터셋에서 이렇게 차이 날 수 없음** → 라벨링 품질 의심

---

## 🎯 4. 권장 실행 계획

### Phase 1: 즉각적 개선 (1일)
1. ✅ **극소 클래스 7개 제거** (29 → 22 클래스)
2. ✅ **이미지 크기 증가** (640 → 1280)
3. ✅ **Learning rate 감소** (0.001 → 0.0005)

**예상 성능**: 56% → 70-75%

### Phase 2: 데이터 품질 개선 (3-5일)
1. ⚠️ Validation set 수동 검증
2. ⚠️ 라벨 오류 수정
3. ⚠️ 애매한 샘플 제거

**예상 성능**: 70-75% → 80-85%

### Phase 3: 고급 최적화 (선택)
1. 🔧 YOLOv8x 또는 YOLOv11 모델 테스트
2. 🔧 Focal Loss 적용
3. 🔧 Multi-scale training

**예상 성능**: 80-85% → 90%+

---

## 📈 5. 예상 성능 향상

| 단계 | 조치 | 예상 mAP50 | 소요 시간 |
|------|------|-----------|-----------|
| **현재** | - | 56.22% | - |
| **Phase 1** | 극소 클래스 제거 + imgsz 1280 | 70-75% | 1일 |
| **Phase 2** | 데이터 검증 + 라벨 수정 | 80-85% | 3-5일 |
| **Phase 3** | 모델 업그레이드 | 90%+ | 2-3일 |

---

## 🚀 6. 다음 단계

### 즉시 실행
```bash
# 1. 극소 클래스 제거 스크립트 실행
python yolo/remove_minority_classes.py

# 2. 새 학습 시작 (22 클래스, imgsz 1280)
bash scripts/train_22classes_1280.sh
```

### 검토 필요
- [ ] 극소 클래스 제거 승인
- [ ] 이미지 크기 1280 VRAM 확인
- [ ] Validation set 수동 검증 일정

---

## 📝 7. 결론

**핵심 문제**: 극소 샘플 클래스 + 심각한 불균형

**즉각 조치**: 극소 클래스 7개 제거 (실용적 선택)

**장기 목표**: 데이터 품질 개선 + 추가 수집

**예상 결과**: 단계별 개선으로 90%+ 달성 가능
